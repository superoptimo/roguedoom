create_file_with_block
textures/BLUEWALL.gif

create_file_with_block
textures/REDWALL.gif

create_file_with_block
textures/BLUEFLOOR.gif

create_file_with_block
textures/REDALTAR.gif

create_file_with_block
textures/BLUEALTAR.gif

create_file_with_block
textures/ELEVATORROOM.gif

create_file_with_block
textures/REDBASEWALL.gif

create_file_with_block
textures/BLUEBASEWALL.gif

create_file_with_block
textures/BLWALLEV.gif

create_file_with_block
textures/BLWALLGH.gif

create_file_with_block
textures/BLWALLKJ.gif

create_file_with_block
textures/BLWALLMJ.gif

create_file_with_block
textures/BLWALLNO.gif

create_file_with_block
textures/BLWALLSW.gif

create_file_with_block
textures/BLWALLUL.gif

create_file_with_block
textures/RDWALLEV.gif

create_file_with_block
textures/RDWALLGH.gif

create_file_with_block
textures/RDWALLKJ.gif

create_file_with_block
textures/RDWALLMJ.gif

create_file_with_block
textures/RDWALLNO.gif

create_file_with_block
textures/RDWALLSW.gif

create_file_with_block
textures/RDWALLUL.gif

create_file_with_block
textures/SKY.gif

create_file_with_block
textures/SPECBASE.gif 

create_file_with_block
textures/SPECRUNE.gif 

create_file_with_block
index.html
<!DOCTYPE html>
<html>
<head>
    <title>Rogue-like DOOM</title>
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
    <div id="blocker">
        <div id="instructions">
            <p style="font-size:36px">Click to play</p>
            <p>Move: WASD<br/>Look: MOUSE<br/>Sprint: SHIFT<br/>Interact (Keys/Gates/Exit/Elevator): E<br/>Shoot: CLICK</p>
            <p id="message-area" style="color: yellow;"></p>
        </div>
    </div>
    <canvas id="gameCanvas"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script src="js/GameConstants.js"></script>
    <script src="js/Cell.js"></script>
    <script src="js/LeonMath.js"></script>
    <script src="js/Labyrinth.js"></script>
    <script src="js/Monster.js"></script> 
    <script type="module" src="js/main.js"></script>
</body>
</html>

create_file_with_block
css/style.css
body { margin: 0; overflow: hidden; }
canvas { display: block; }
#blocker {
    position: absolute;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.5);
    display: flex; 
    justify-content: center; 
    align-items: center; 
}
#instructions {
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    text-align: center;
    font-size: 14px;
    cursor: pointer;
    color: white;
}
#message-area {
    margin-top: 20px;
    font-size: 16px;
    min-height: 20px; 
}

create_file_with_block
js/GameConstants.js
const GameConstants = {
    KEY_RED: 'KEY_RED',
    KEY_YELLOW: 'KEY_YELLOW',
    KEY_BLUE: 'KEY_BLUE',

    GATE_RED: 'GATE_RED',
    GATE_YELLOW: 'GATE_YELLOW',
    GATE_BLUE: 'GATE_BLUE',
};

if (typeof window !== 'undefined') {
    window.GameConstants = GameConstants;
}

create_file_with_block
js/Cell.js
class Cell {
    constructor(row, column) {
        this.m_row = row;
        this.m_column = column;
        this.m_upstairs = false; 
        this.SouthBound = true; 
        this.EastBound = true;  
        this.mark = Cell.NORMALROOM; 
        this.m_entities = []; 
        this.mark2 = 0; 
        this.keyType = null;   
        this.gateType = null;  
        this.isGateOpen = false;
        this.isExit = false; 
        this.isElevatorPlatform = false; // Marks the interactive part of the elevator
    }
    static NORMALROOM=0; static ELEVATORROOM=1; static ELEVATOR=2; /* ELEVATOR mark might be used for the platform cell */ static REDALTAR=3; static REDSOURCE=4; static REDBASE=5; 
    static BLUEALTAR=6; static BLUESOURCE=7; static BLUEBASE=8; static EMPTY=9;        
}
if(typeof window!=='undefined'&&typeof window.Cell==='undefined')window.Cell=Cell;

create_file_with_block
js/LeonMath.js
class LeonMath {
    static collisionSphereVelPlane(spherePos, sphereVel, sphereRad, plane, outNormal, outPoint) {
        const dist = plane.distanceToPoint(spherePos);
        const dotVelNorm = sphereVel.dot(plane.normal);
        if (Math.abs(dist) <= sphereRad) {
            if (dotVelNorm <= 1e-6) { 
                if (outNormal) outNormal.copy(plane.normal);
                if (outPoint) plane.projectPoint(spherePos, outPoint).addScaledVector(plane.normal, -sphereRad * Math.sign(dist||1e-6));
                return 0.0;
            }
            return Infinity; 
        }
        if (dotVelNorm < -1e-6) { 
            let t = (dist > 0 ? dist - sphereRad : dist + sphereRad) / -dotVelNorm;
            if ( (dist > 0 && (t * -dotVelNorm) > dist + sphereRad * 2) || (dist < 0 && (t * -dotVelNorm) > -dist + sphereRad * 2 ) ){
                 return Infinity;
            }
            if (t >= 0 && t <= 1.0) {
                if (outNormal) outNormal.copy(plane.normal);
                if (outPoint) outPoint.copy(spherePos).addScaledVector(sphereVel, t).addScaledVector(plane.normal, -sphereRad);
                return t;
            }
        }
        return Infinity;
    }
    static collisionSphereVelSphere(p1,v1,r1,p2,v2,r2,n,pt){return Infinity;} 
}
if(typeof window!=='undefined'&&typeof window.LeonMath==='undefined')window.LeonMath=LeonMath;

create_file_with_block
js/Labyrinth.js
// Uses Cell.js, GameConstants.js, LeonMath.js, Monster.js (expected to be global)

class Labyrinth {
    static MAXELEVATORS=4; static CELLWIDTH=6.0; static CELLHEIGHT=4.0; 
    static WALLTHICKNESS=0.25; static NUM_ROWS=20; static NUM_COLS=20; static NUM_FLOORS=2;

    constructor(){
        this.cells=new Array(Labyrinth.NUM_ROWS*Labyrinth.NUM_COLS*Labyrinth.NUM_FLOORS);
        this.elevator_row=new Array(Labyrinth.MAXELEVATORS);this.elevator_col=new Array(Labyrinth.MAXELEVATORS);
        this.elevatorCount=0;this.keyMeshes=[];this.gateMeshes=[];this.monsters=[];this.exitMesh=null;
        this.elevatorPlatformMeshes = []; // For elevator platforms
        
        this.textureLoader = new THREE.TextureLoader();
        this.textures = {
            redFloor: this.loadTexture('textures/REDFLOOR.gif'), blueWall: this.loadTexture('textures/BLUEWALL.gif'), 
            redWall: this.loadTexture('textures/REDWALL.gif'), blueFloor: this.loadTexture('textures/BLUEFLOOR.gif'),
            redAltar: this.loadTexture('textures/REDALTAR.gif'), blueAltar: this.loadTexture('textures/BLUEALTAR.gif'), 
            elevatorRoom: this.loadTexture('textures/ELEVATORROOM.gif'), // For shaft walls
            elevatorPlatform: this.loadTexture('textures/SPECBASE.gif'), // Generic metal for platform
            redBaseWall: this.loadTexture('textures/REDBASEWALL.gif'), blueBaseWall: this.loadTexture('textures/BLUEBASEWALL.gif'),
            defaultCeiling: this.loadTexture('textures/BLWALLUL.gif'), exitPortal: this.loadTexture('textures/REDALTAR.gif'),   
            defaultGate: this.loadTexture('textures/REDWALL.gif')    
        };

        for(let i=0;i<Labyrinth.NUM_ROWS;i++)for(let j=0;j<Labyrinth.NUM_COLS;j++){
            this.cells[i*Labyrinth.NUM_COLS+j]=new Cell(i,j);this.cells[i*Labyrinth.NUM_COLS+j].m_upstairs=false;
            this.cells[Labyrinth.NUM_ROWS*Labyrinth.NUM_COLS+i*Labyrinth.NUM_COLS+j]=new Cell(i,j);this.cells[Labyrinth.NUM_ROWS*Labyrinth.NUM_COLS+i*Labyrinth.NUM_COLS+j].m_upstairs=true;
        }
    }
    loadTexture(path) {
        const texture = this.textureLoader.load(path, undefined,undefined, (err)=>{console.error(`Failed to load texture: ${path}`, err);});
        texture.wrapS = THREE.RepeatWrapping; texture.wrapT = THREE.RepeatWrapping;
        texture.magFilter = THREE.NearestFilter; texture.minFilter = THREE.LinearMipmapLinearFilter; 
        texture.colorSpace = THREE.SRGBColorSpace; 
        return texture;
    }
    getCell(r,c,up){if(r<0||r>=Labyrinth.NUM_ROWS||c<0||c>=Labyrinth.NUM_COLS)return null;return this.cells[(up?Labyrinth.NUM_ROWS*Labyrinth.NUM_COLS:0)+r*Labyrinth.NUM_COLS+c];}
    getDownstairsCell(r,c){return this.getCell(r,c,false);}
    getUpstairsCell(r,c){return this.getCell(r,c,true);}

    generateLabyrinth(){
        for(let i=0;i<this.cells.length;i++){this.cells[i].mark=Cell.NORMALROOM;this.cells[i].SouthBound=true;this.cells[i].EastBound=true;this.cells[i].keyType=null;this.cells[i].gateType=null;this.cells[i].isGateOpen=false;this.cells[i].isExit=false;this.cells[i].isElevatorPlatform=false;}
        this.baserojax=Math.floor(Math.random()*(Labyrinth.NUM_COLS-5))+2;this.baserojay=Math.floor(Math.random()*(Labyrinth.NUM_ROWS-5))+2;
        for(let i=0;i<3;i++)for(let j=0;j<3;j++){let c1=this.getDownstairsCell(this.baserojay+i,this.baserojax+j);if(c1)c1.mark=Cell.REDBASE;let c2=this.getUpstairsCell(this.baserojay+i,this.baserojax+j);if(c2)c2.mark=Cell.REDBASE;}
        let c=this.getDownstairsCell(this.baserojay+1,this.baserojax+1);if(c)c.mark=Cell.REDALTAR;c=this.getDownstairsCell(this.baserojay,this.baserojax);if(c)c.mark=Cell.REDSOURCE;c=this.getDownstairsCell(this.baserojay+2,this.baserojax+2);if(c)c.mark=Cell.REDSOURCE;
        let l=0;do{this.baseazulx=Math.floor(Math.random()*(Labyrinth.NUM_COLS-5))+2;this.baseazuly=Math.floor(Math.random()*(Labyrinth.NUM_ROWS-5))+2;l++;if(l>1000)break;}while((this.baseazulx>=this.baserojax-3&&this.baseazulx<=this.baserojax+3)&&(this.baseazuly>=this.baserojay-3&&this.baseazuly<=this.baserojay+3));
        for(let i=0;i<3;i++)for(let j=0;j<3;j++){let c1=this.getDownstairsCell(this.baseazuly+i,this.baseazulx+j);if(c1)c1.mark=Cell.BLUEBASE;let c2=this.getUpstairsCell(this.baseazuly+i,this.baseazulx+j);if(c2)c2.mark=Cell.BLUEBASE;}
        c=this.getDownstairsCell(this.baseazuly+1,this.baseazulx+1);if(c)c.mark=Cell.BLUEALTAR;c=this.getDownstairsCell(this.baseazuly,this.baseazulx);if(c)c.mark=Cell.BLUESOURCE;c=this.getDownstairsCell(this.baseazuly+2,this.baseazulx+2);if(c)c.mark=Cell.BLUESOURCE;
        const blueSourceExitCell = this.getUpstairsCell(this.baseazuly + 2, this.baseazulx + 2); 
        if (blueSourceExitCell) { blueSourceExitCell.isExit = true;} else {let ep=false;for(let k=0;k<100&&!ep;k++){let er=Math.floor(Math.random()*Labyrinth.NUM_ROWS),ec=Math.floor(Math.random()*Labyrinth.NUM_COLS),exC=this.getUpstairsCell(er,ec);if(exC&&exC.mark===Cell.NORMALROOM){exC.isExit=true;ep=true;}}if(!ep)console.error("Failed to place exit!");}
        
        this.elevatorCount=0;let att=0;while(this.elevatorCount<Labyrinth.MAXELEVATORS&&att<1000){att++;let r=Math.floor(Math.random()*Labyrinth.NUM_ROWS),col=Math.floor(Math.random()*Labyrinth.NUM_COLS);let dc=this.getDownstairsCell(r,col),uc=this.getUpstairsCell(r,col);if(dc&&uc&&dc.mark===Cell.NORMALROOM&&uc.mark===Cell.NORMALROOM){let cf=false;for(let k=0;k<this.elevatorCount;k++)if(this.elevator_row[k]===r&&this.elevator_col[k]===col){cf=true;break;}if(!cf){this.elevator_row[this.elevatorCount]=r;this.elevator_col[this.elevatorCount]=col;dc.mark=Cell.ELEVATORROOM;uc.mark=Cell.ELEVATORROOM; dc.isElevatorPlatform=true; uc.isElevatorPlatform=true; /* Mark both for interaction */ this.elevatorCount++;}}}

        for(let fl=0;fl<Labyrinth.NUM_FLOORS;fl++)for(let i=0;i<Labyrinth.NUM_ROWS;i++)for(let j=0;j<Labyrinth.NUM_COLS;j++){let cl=this.getCell(i,j,fl===1);if(!cl)continue;if(cl.mark===Cell.NORMALROOM){cl.SouthBound=(i===Labyrinth.NUM_ROWS-1)?true:(Math.random()>0.5);cl.EastBound=(j===Labyrinth.NUM_COLS-1)?true:(Math.random()>0.5);}else if(cl.mark>=Cell.REDALTAR&&cl.mark<=Cell.BLUEBASE){const sB=(nM)=>nM===cl.mark||((cl.mark===Cell.REDALTAR||cl.mark===Cell.REDSOURCE)&&nM===Cell.REDBASE)||((cl.mark===Cell.BLUEALTAR||cl.mark===Cell.BLUESOURCE)&&nM===Cell.BLUEBASE);cl.SouthBound=(i===Labyrinth.NUM_ROWS-1)?true:!sB(this.getCell(i+1,j,fl===1)?.mark);cl.EastBound=(j===Labyrinth.NUM_COLS-1)?true:!sB(this.getCell(i,j+1,fl===1)?.mark);if(i>0){let n=this.getCell(i-1,j,fl===1);if(n&&sB(n.mark))n.SouthBound=false;else if(n)n.SouthBound=true;}if(j>0){let n=this.getCell(i,j-1,fl===1);if(n&&sB(n.mark))n.EastBound=false;else if(n)n.EastBound=true;}}}
        this.placeKeysAndGates();
    }
    placeKeysAndGates(){const gC=[];let rgr,rgc,cfgw,cbg;rgr=this.baserojay+2;rgc=this.baserojax+1;cfgw=this.getDownstairsCell(rgr,rgc);cbg=this.getDownstairsCell(rgr+1,rgc);if(cfgw&&(cfgw.mark===Cell.REDBASE||cfgw.mark===Cell.REDALTAR)&&cbg&&cbg.mark===Cell.NORMALROOM){cfgw.SouthBound=true;cfgw.gateType=GameConstants.GATE_RED;gC.push(cfgw);}else console.warn("Red Gate S failed.");rgr=this.baseazuly+1;rgc=this.baseazulx+2;cfgw=this.getDownstairsCell(rgr,rgc);cbg=this.getDownstairsCell(rgr,rgc+1);if(cfgw&&(cfgw.mark===Cell.BLUEBASE||cfgw.mark===Cell.BLUEALTAR)&&cbg&&cbg.mark===Cell.NORMALROOM){cfgw.EastBound=true;cfgw.gateType=GameConstants.GATE_BLUE;gC.push(cfgw);}else console.warn("Blue Gate E failed.");let yGP=false;for(let a=0;a<200&&!yGP;a++){let r=Math.floor(Math.random()*(Labyrinth.NUM_ROWS-1)),c=Math.floor(Math.random()*(Labyrinth.NUM_COLS-1)),cl=this.getDownstairsCell(r,c);if(cl&&cl.mark===Cell.NORMALROOM&&!cl.gateType&&!cl.keyType){if(Math.random()<0.5&&(r<Labyrinth.NUM_ROWS-1)){let n=this.getDownstairsCell(r+1,c);if(n&&n.mark===Cell.NORMALROOM&&!n.gateType&&!n.keyType){cl.SouthBound=true;cl.gateType=GameConstants.GATE_YELLOW;gC.push(cl);yGP=true;}}else if(c<Labyrinth.NUM_COLS-1){let n=this.getDownstairsCell(r,c+1);if(n&&n.mark===Cell.NORMALROOM&&!n.gateType&&!n.keyType){cl.EastBound=true;cl.gateType=GameConstants.GATE_YELLOW;gC.push(cl);yGP=true;}}}}if(!yGP)console.warn("Yellow Gate failed.");const bAC=this.getDownstairsCell(this.baseazuly+1,this.baseazulx+1);if(bAC)bAC.keyType=GameConstants.KEY_RED;const rAC=this.getDownstairsCell(this.baserojay+1,this.baserojax+1);if(rAC)rAC.keyType=GameConstants.KEY_BLUE;let yKP=false;for(let a=0;a<200&&!yKP;a++){let r=Math.floor(Math.random()*Labyrinth.NUM_ROWS),c=Math.floor(Math.random()*Labyrinth.NUM_COLS),cl=this.getDownstairsCell(r,c);if(cl&&cl.mark===Cell.NORMALROOM&&!cl.keyType&&!cl.gateType&&!gC.some(gc=>gc.m_row===r&&gc.m_column===c)){if(!((r>=this.baserojay&&r<=this.baserojay+2&&c>=this.baserojax&&c<=this.baserojax+2)||(r>=this.baseazuly&&r<=this.baseazuly+2&&c>=this.baseazulx&&c<=this.baseazulx+2))){cl.keyType=GameConstants.KEY_YELLOW;yKP=true;}}}if(!yKP)console.warn("Yellow Key failed");}
    
    spawnMonsters(num, scene, playerCellRC) {
        this.monsters.forEach(m => m.mesh && scene.remove(m.mesh)); this.monsters = [];
        const occupied = new Set(); if(playerCellRC) occupied.add(`${playerCellRC.r}-${playerCellRC.c}-false`);
        for(let i=0;i<num;i++){let sp=false,att=0;while(!sp&&att<100){att++;
            let r=Math.floor(Math.random()*Labyrinth.NUM_ROWS),c=Math.floor(Math.random()*Labyrinth.NUM_COLS),up=false; 
            const cl=this.getCell(r,c,up),ck=`${r}-${c}-${up}`;
            if(cl&&cl.mark===Cell.NORMALROOM&&!occupied.has(ck)&&!cl.keyType&&!cl.gateType&&!cl.isExit&&!cl.isElevatorPlatform&&!((r>=this.baserojay-1&&r<=this.baserojay+3&&c>=this.baserojax-1&&c<=this.baserojax+3)||(r>=this.baseazuly-1&&r<=this.baseazuly+3&&c>=this.baseazulx-1&&c<=this.baseazulx+3))){
                const p=new THREE.Vector3(c*Labyrinth.CELLWIDTH+Labyrinth.CELLWIDTH/2,(up?Labyrinth.CELLHEIGHT:0)+0.9,r*Labyrinth.CELLWIDTH+Labyrinth.CELLWIDTH/2);
                const mon=new Monster(p,scene,0xddaa00,`mon-${i}`);mon.currentCell=cl;this.monsters.push(mon);occupied.add(ck);sp=true;
            }
        }if(!sp)console.warn(`Monster ${i} spawn failed.`);}
    }

    create3DRepresentation(s,cW,cH,wT){if(this.exitMesh)s.remove(this.exitMesh);this.exitMesh=null;this.keyMeshes.forEach(k=>s.remove(k));this.keyMeshes=[];this.gateMeshes.forEach(g=>s.remove(g));this.gateMeshes=[];this.elevatorPlatformMeshes.forEach(e=>s.remove(e));this.elevatorPlatformMeshes=[];
        const kM={[GameConstants.KEY_RED]:new THREE.MeshStandardMaterial({color:0xff3333,emissive:0x550000,roughness:0.5,metalness:0.3}),[GameConstants.KEY_YELLOW]:new THREE.MeshStandardMaterial({color:0xffff33,emissive:0x555500,roughness:0.5,metalness:0.3}),[GameConstants.KEY_BLUE]:new THREE.MeshStandardMaterial({color:0x3333ff,emissive:0x000055,roughness:0.5,metalness:0.3})};
        const gM={[GameConstants.GATE_RED]:new THREE.MeshPhongMaterial({map:this.textures.redBaseWall,color:0xff8888,transparent:true,opacity:0.75,shininess:60}),[GameConstants.GATE_YELLOW]:new THREE.MeshPhongMaterial({map:this.textures.defaultGate,color:0xffff88,transparent:true,opacity:0.75,shininess:60}),[GameConstants.GATE_BLUE]:new THREE.MeshPhongMaterial({map:this.textures.blueBaseWall,color:0x8888ff,transparent:true,opacity:0.75,shininess:60})};
        const exitMat = new THREE.MeshStandardMaterial({color: 0x00dddd, emissive: 0x00aaaa, roughness: 0.2, metalness: 0.8, side: THREE.DoubleSide, map:this.textures.exitPortal});
        const exitGeo = new THREE.PlaneGeometry(cW*0.8, cH*0.8);
        const elevatorPlatformMaterial = new THREE.MeshStandardMaterial({map: this.textures.elevatorPlatform, roughness: 0.4, metalness: 0.6});


        for(let fl=0;fl<Labyrinth.NUM_FLOORS;fl++){const up=fl===1,yO=up?cH:0;
            for(let r=0;r<Labyrinth.NUM_ROWS;r++)for(let c=0;c<Labyrinth.NUM_COLS;c++){const cl=this.getCell(r,c,up);if(!cl||cl.mark===Cell.EMPTY)continue;const cX=c*cW+cW/2,cZ=r*cW+cW/2;
                let floorMaterial, wallMaterial, ceilingMaterial;
                ceilingMaterial = new THREE.MeshStandardMaterial({map:this.textures.defaultCeiling, roughness:0.8, metalness:0.2});

                if(cl.mark===Cell.REDBASE){floorMaterial=new THREE.MeshStandardMaterial({map:this.textures.redFloor});wallMaterial=new THREE.MeshStandardMaterial({map:this.textures.redBaseWall});}
                else if(cl.mark===Cell.BLUEBASE){floorMaterial=new THREE.MeshStandardMaterial({map:this.textures.blueFloor});wallMaterial=new THREE.MeshStandardMaterial({map:this.textures.blueBaseWall});}
                else if(cl.mark===Cell.REDALTAR || cl.mark === Cell.REDSOURCE){floorMaterial=new THREE.MeshStandardMaterial({map:this.textures.redFloor});wallMaterial=new THREE.MeshStandardMaterial({map:this.textures.redAltar});}
                else if(cl.mark===Cell.BLUEALTAR || cl.mark === Cell.BLUESOURCE){floorMaterial=new THREE.MeshStandardMaterial({map:this.textures.blueFloor});wallMaterial=new THREE.MeshStandardMaterial({map:this.textures.blueAltar});}
                else if(cl.mark===Cell.ELEVATORROOM || cl.isElevatorPlatform){floorMaterial=new THREE.MeshStandardMaterial({map:this.textures.elevatorRoom});wallMaterial=new THREE.MeshStandardMaterial({map:this.textures.elevatorRoom});} // Shaft walls
                else {floorMaterial = new THREE.MeshStandardMaterial({map:(up ? this.textures.blueFloor : this.textures.redFloor)});wallMaterial = new THREE.MeshStandardMaterial({map:(up ? this.textures.blueWall : this.textures.redWall)}); }
                
                if(cl.isElevatorPlatform) { // Render distinct platform
                    const platformGeo = new THREE.CylinderGeometry(cW*0.4, cW*0.4, cH*0.1, 16);
                    const platformMesh = new THREE.Mesh(platformGeo, elevatorPlatformMaterial);
                    platformMesh.position.set(cX, yO + cH*0.05, cZ); // Slightly above floor
                    platformMesh.userData = { type: 'elevator', cellR: r, cellC: c, currentFloor: fl };
                    this.elevatorPlatformMeshes.push(platformMesh); s.add(platformMesh);
                } else { // Normal floor rendering
                    const flMsh=new THREE.Mesh(new THREE.BoxGeometry(cW,wT,cW),floorMaterial);flMsh.receiveShadow=true;s.add(flMsh.position.set(cX,yO-wT/2,cZ));
                }

                const ceMsh=new THREE.Mesh(new THREE.BoxGeometry(cW,wT,cW),ceilingMaterial);ceMsh.castShadow=true;s.add(ceMsh.position.set(cX,yO+cH+wT/2,cZ));
                if(cl.SouthBound){if(!up&&cl.gateType&&!cl.isGateOpen){const g=new THREE.Mesh(new THREE.BoxGeometry(cW,cH,wT*2),gM[cl.gateType]);g.position.set(cX,yO+cH/2,cZ+cW/2-wT);g.userData={type:'gate',gateType:cl.gateType,cellR:r,cellC:c,bound:'South',mesh:g};this.gateMeshes.push(g);s.add(g);g.castShadow=true;}else if(!cl.gateType||cl.isGateOpen){const sw=new THREE.Mesh(new THREE.BoxGeometry(cW,cH,wT),wallMaterial);sw.position.set(cX,yO+cH/2,cZ+cW/2-wT/2);sw.castShadow=true;sw.receiveShadow=true;s.add(sw);}}
                if(cl.EastBound){if(!up&&cl.gateType&&!cl.isGateOpen){const g=new THREE.Mesh(new THREE.BoxGeometry(wT*2,cH,cW),gM[cl.gateType]);g.position.set(cX+cW/2-wT,yO+cH/2,cZ);g.userData={type:'gate',gateType:cl.gateType,cellR:r,cellC:c,bound:'East',mesh:g};this.gateMeshes.push(g);s.add(g);g.castShadow=true;}else if(!cl.gateType||cl.isGateOpen){const ew=new THREE.Mesh(new THREE.BoxGeometry(wT,cH,cW),wallMaterial);ew.position.set(cX+cW/2-wT/2,yO+cH/2,cZ);ew.castShadow=true;ew.receiveShadow=true;s.add(ew);}}
                if(r===0){const nw=new THREE.Mesh(new THREE.BoxGeometry(cW,cH,wT),wallMaterial);nw.position.set(cX,yO+cH/2,cZ-cW/2+wT/2);nw.castShadow=true;nw.receiveShadow=true;s.add(nw);}
                if(c===0){const ww=new THREE.Mesh(new THREE.BoxGeometry(wT,cH,cW),wallMaterial);ww.position.set(cX-cW/2+wT/2,yO+cH/2,cZ);ww.castShadow=true;ww.receiveShadow=true;s.add(ww);}
                if(!up&&cl.keyType){const kMh=new THREE.Mesh(new THREE.TorusKnotGeometry(cW/10,cW/25,50,8),kM[cl.keyType]);kMh.position.set(cX,yO+cH/3,cZ);kMh.userData={type:'key',keyType:cl.keyType,cellR:r,cellC:c,mesh:kMh};this.keyMeshes.push(kMh);s.add(kMh);kMh.castShadow=true;}
                if(cl.isExit&&up){this.exitMesh=new THREE.Mesh(exitGeo,exitMat);this.exitMesh.position.set(cX,yO+wT*1.5,cZ);this.exitMesh.rotation.x=-Math.PI/2;this.exitMesh.userData={type:'exit',cellR:r,cellC:c,isUpstairs:up};s.add(this.exitMesh);}}}}
    getCellByPosition(pos,isUpstairs=null){ // isUpstairs can be null to auto-detect
        let onUpperFloor = (isUpstairs === null) ? (pos.y > Labyrinth.CELLHEIGHT/2) : isUpstairs;
        const c=Math.floor(pos.x/Labyrinth.CELLWIDTH),r=Math.floor(pos.z/Labyrinth.CELLWIDTH);return this.getCell(r,c,onUpperFloor);}
    crossLabyrinth(rad,p1c,p2t,nf,cf){const ip2t=p2t.clone();let p1=p1c.clone();
        let currentFloorIsUpstairs = p1.y > Labyrinth.CELLHEIGHT / 2; // Determine current floor
        let ccd=this.getCellByPosition(p1,currentFloorIsUpstairs);

        if(!ccd){p2t.copy(p1c);if(nf)nf.set(0,1,0);return false;}if(Labyrinth.markCounter===undefined)Labyrinth.markCounter=0;Labyrinth.markCounter++;let col=false,pm=10,pr=0,pch=false;let vv=new THREE.Vector3().subVectors(ip2t,p1);let cn=new THREE.Vector3(),cp=new THREE.Vector3();
        
        // Y-axis clamping for current floor before iterative checks
        const currentFloorYBase = currentFloorIsUpstairs ? Labyrinth.CELLHEIGHT : 0;
        if(p1.y-rad < currentFloorYBase && vv.y <0){p1.y=currentFloorYBase+rad;vv.y=0;pch=true;if(nf)nf.set(0,1,0);}
        if(p1.y+rad > currentFloorYBase + Labyrinth.CELLHEIGHT && vv.y > 0){p1.y=currentFloorYBase+Labyrinth.CELLHEIGHT-rad;vv.y=0;pch=true;if(nf)nf.set(0,-1,0);}


        do{pr++;col=false;let tm=1.0;ccd=this.getCellByPosition(p1,currentFloorIsUpstairs);if(!ccd){p2t.copy(p1);if(nf)nf.set(0,1,0);return true;}ccd.mark2=Labyrinth.markCounter;
            const floorPlaneY = currentFloorIsUpstairs ? Labyrinth.CELLHEIGHT : 0;
            const ceilingPlaneY = currentFloorIsUpstairs ? Labyrinth.CELLHEIGHT * 2 : Labyrinth.CELLHEIGHT;

            const fp=new THREE.Plane(new THREE.Vector3(0,1,0),-floorPlaneY);let tF=LeonMath.collisionSphereVelPlane(p1,vv,rad,fp,cn,cp);if(tF>=0&&tF<tm){tm=tF;if(nf)nf.copy(cn);col=true;}
            const cp_=new THREE.Plane(new THREE.Vector3(0,-1,0),ceilingPlaneY);let tC=LeonMath.collisionSphereVelPlane(p1,vv,rad,cp_,cn,cp);if(tC>=0&&tC<tm){tm=tC;if(nf)nf.copy(cn);col=true;}
            
            const crr=Math.ceil(Math.abs(vv.z/Labyrinth.CELLWIDTH))+1,crc=Math.ceil(Math.abs(vv.x/Labyrinth.CELLWIDTH))+1;
            for(let dr=-crr;dr<=crr;dr++)for(let dc=-crc;dc<=crc;dc++){let cl=this.getCell(ccd.m_row+dr,ccd.m_column+dc, currentFloorIsUpstairs);if(!cl)continue; // Check cells on current floor
                const cmnx=cl.m_column*Labyrinth.CELLWIDTH,cmxx=(cl.m_column+1)*Labyrinth.CELLWIDTH,cmnz=cl.m_row*Labyrinth.CELLWIDTH,cmxz=(cl.m_row+1)*Labyrinth.CELLWIDTH;let tc;
                if(cl.SouthBound&&(!cl.gateType||(cl.gateType&&!cl.isGateOpen))){const pl=new THREE.Plane(new THREE.Vector3(0,0,-1),cmxz);tc=LeonMath.collisionSphereVelPlane(p1,vv,rad,pl,cn,cp);if(tc>=0&&tc<tm){tm=tc;if(nf)nf.copy(cn);col=true;}}
                if(cl.EastBound&&(!cl.gateType||(cl.gateType&&!cl.isGateOpen))){const pl=new THREE.Plane(new THREE.Vector3(-1,0,0),cmxx);tc=LeonMath.collisionSphereVelPlane(p1,vv,rad,pl,cn,cp);if(tc>=0&&tc<tm){tm=tc;if(nf)nf.copy(cn);col=true;}}
                let iNW=(cl.m_row===0),nCl=this.getCell(cl.m_row-1,cl.m_column, currentFloorIsUpstairs);if(!iNW&&nCl&&nCl.SouthBound&&(!nCl.gateType||(nCl.gateType&&!nCl.isGateOpen)))iNW=true;else if(cl.m_row===0)iNW=true; else iNW=false; 
                if(iNW){const pl=new THREE.Plane(new THREE.Vector3(0,0,1),-cmnz);tc=LeonMath.collisionSphereVelPlane(p1,vv,rad,pl,cn,cp);if(tc>=0&&tc<tm){tm=tc;if(nf)nf.copy(cn);col=true;}}
                let iWW=(cl.m_column===0),wCl=this.getCell(cl.m_row,cl.m_column-1, currentFloorIsUpstairs);if(!iWW&&wCl&&wCl.EastBound&&(!wCl.gateType||(wCl.gateType&&!wCl.isGateOpen)))iWW=true;else if(cl.m_column===0)iWW=true; else iWW=false;
                if(iWW){const pl=new THREE.Plane(new THREE.Vector3(1,0,0),-cmnx);tc=LeonMath.collisionSphereVelPlane(p1,vv,rad,pl,cn,cp);if(tc>=0&&tc<tm){tm=tc;if(nf)nf.copy(cn);col=true;}}
            }
            if(col&&tm<Infinity&&tm>=0&&tm<=1.0){pch=true;const ep=0.001;p1.addScaledVector(vv,Math.max(0,tm-ep));let rtf=1.0-Math.max(0,tm-ep);if(rtf<0)rtf=0;let rv=vv.clone().multiplyScalar(rtf);let dot=rv.dot(nf);rv.addScaledVector(nf,-dot*1.01);vv.copy(rv);
            }else{p1.add(vv);vv.set(0,0,0);col=false;}
        }while(col&&pr<pm&&vv.lengthSq()>0.00001);
        p2t.copy(p1);let fd=this.getCellByPosition(p2t,false),fu=this.getCellByPosition(p2t,true);
        if(cf){cf.length=0;if(fd)cf.push(fd);if(fu&&fu!==fd)cf.push(fu);}
        return pch||!p2t.equals(ip2t);
    }
}
if(typeof window!=='undefined'&&typeof window.Labyrinth==='undefined')window.Labyrinth=Labyrinth;

create_file_with_block
js/Monster.js
// Uses THREE.js, Labyrinth.js (expected to be global)
// PLAYER_RADIUS is expected to be a global constant for LoS check against player

class Monster {
    static idCounter = 0;

    constructor(startPosition, scene, color = 0xff0000, id = null) {
        this.id = id !== null ? id : `monster-${Monster.idCounter++}`;
        this.position = startPosition.clone();
        this.health = 100;
        this.speed = 2.0; 
        this.detectionRadius = 12; 
        this.attackRadius = 2.0; 
        this.currentCell = null; 
        this.state = 'IDLE'; 
        this.mesh = null;
        this.lastAttackTime = 0;
        this.attackCooldown = 1500; 
        this.lastLoSCheckTime = 0;
        this.canSeePlayer = false;
        this.playerMemoryPosition = null; 
        this.memoryDuration = 4000; 
        this.lastMemoryTime = 0;
        this.idleWanderTarget = null;
        this.lastWanderDecisionTime = 0;
        this.monsterRadius = 0.35; 

        this.createMesh(scene, color);
    }

    createMesh(scene, color) {
        const geometry = new THREE.CylinderGeometry(this.monsterRadius, this.monsterRadius * 1.2, 1.8, 8); 
        const material = new THREE.MeshStandardMaterial({ color: color, roughness: 0.6, metalness: 0.3 });
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.position.copy(this.position);
        this.mesh.userData.monster = this; 
        this.mesh.castShadow = true;
        scene.add(this.mesh);
    }

    update(deltaTime, playerCamera, labyrinth, scene) { 
        if (this.state === 'DEAD' || !this.mesh) return;

        const playerPosition = playerCamera.position;
        const distanceToPlayer = this.position.distanceTo(playerPosition);

        if (Date.now() - this.lastLoSCheckTime > 300 + Math.random()*200) { 
            const directionToPlayer = playerPosition.clone().sub(this.position).normalize();
            const raycaster = new THREE.Raycaster(this.position, directionToPlayer, 0.1, this.detectionRadius);
            const intersects = raycaster.intersectObjects(scene.children, false); 
            
            this.canSeePlayer = false;
            if (intersects.length > 0) {
                let firstMeaningfulHit = null;
                for(let i=0; i < intersects.length; i++){
                    if(intersects[i].object !== this.mesh && (!intersects[i].object.userData.monster)) { 
                        firstMeaningfulHit = intersects[i];
                        break;
                    }
                }
                const playerActualRadius = typeof PLAYER_RADIUS !== 'undefined' ? PLAYER_RADIUS : 0.35; 
                if (firstMeaningfulHit && (firstMeaningfulHit.object.userData.isPlayer || (firstMeaningfulHit.object.parent && firstMeaningfulHit.object.parent.userData.isPlayer) || firstMeaningfulHit.distance > distanceToPlayer - playerActualRadius * 0.8 ) ) {
                    this.canSeePlayer = true;
                }
            } else if (distanceToPlayer < this.detectionRadius) { 
                this.canSeePlayer = true;
            }
            this.lastLoSCheckTime = Date.now();
        }

        if (this.canSeePlayer && distanceToPlayer < this.detectionRadius) {
            this.playerMemoryPosition = playerPosition.clone(); this.lastMemoryTime = Date.now();
            this.state = (distanceToPlayer < this.attackRadius) ? 'ATTACKING' : 'CHASING';
        } else {
            if (this.playerMemoryPosition && (Date.now() - this.lastMemoryTime < this.memoryDuration)) this.state = 'CHASING';
            else {this.playerMemoryPosition = null; this.state = 'IDLE';}
        }
        
        const moveDirection = new THREE.Vector3();
        let targetChasePosition = this.playerMemoryPosition ? this.playerMemoryPosition : playerPosition; 

        if (this.state === 'CHASING') {
            moveDirection.subVectors(targetChasePosition, this.position).normalize(); moveDirection.y = 0; 
            const intendedMove = moveDirection.multiplyScalar(this.speed * deltaTime);
            const targetPosition = this.position.clone().add(intendedMove);
            const colN=new THREE.Vector3(), oY=this.position.y;
            labyrinth.crossLabyrinth(this.monsterRadius, this.position.clone(), targetPosition, colN, []);
            this.position.copy(targetPosition); this.position.y = oY;
            if(this.mesh) this.mesh.lookAt(targetChasePosition.x, this.mesh.position.y, targetChasePosition.z);
        } else if (this.state === 'ATTACKING') {
            if(this.mesh) this.mesh.lookAt(playerPosition.x, this.mesh.position.y, playerPosition.z);
            if (Date.now() - this.lastAttackTime > this.attackCooldown) {
                if(window.playerHealthSystem && typeof window.playerHealthSystem.takeDamage === 'function'){
                    window.playerHealthSystem.takeDamage(10 + Math.floor(Math.random()*6)); 
                }
                this.lastAttackTime = Date.now();
            }
        } else if (this.state === 'IDLE') {
            if (!this.idleWanderTarget || this.position.distanceTo(this.idleWanderTarget) < 0.8 || Date.now() - this.lastWanderDecisionTime > (Math.random()*4000+3000)) {
                const angle=Math.random()*Math.PI*2, dist=Math.random()*4+2;
                this.idleWanderTarget = new THREE.Vector3(this.position.x+Math.cos(angle)*dist, this.position.y, this.position.z+Math.sin(angle)*dist);
                this.lastWanderDecisionTime = Date.now();
            }
            if (this.idleWanderTarget) {
                moveDirection.subVectors(this.idleWanderTarget,this.position).normalize();moveDirection.y=0;
                const intendedMove=moveDirection.multiplyScalar(this.speed*0.4*deltaTime); 
                const targetPosition=this.position.clone().add(intendedMove);
                const colN=new THREE.Vector3(),oY=this.position.y;
                labyrinth.crossLabyrinth(this.monsterRadius,this.position.clone(),targetPosition,colN,[]);
                this.position.copy(targetPosition);this.position.y=oY;
            }
        }
        if(this.mesh) this.mesh.position.copy(this.position);
    }

    takeDamage(amount, scene) {
        if(this.state==='DEAD')return; this.health-=amount; console.log(`Monster ${this.id} HP: ${this.health}`);
        if(this.mesh){this.mesh.material.emissive.setHex(0xff0000);setTimeout(()=>this.mesh&&this.mesh.material.emissive.setHex(0x000000),150);}
        if(this.health<=0)this.die(scene);
    }
    die(scene){console.log(`Monster ${this.id} died.`);this.state='DEAD';if(this.mesh){scene.remove(this.mesh);this.mesh.geometry.dispose();this.mesh.material.dispose();this.mesh=null;}}
    isDead(){return this.state==='DEAD';}
}
if(typeof window!=='undefined'&&typeof window.Monster==='undefined')window.Monster=Monster;

create_file_with_block
js/vendor/three/examples/jsm/controls/PointerLockControls.js
import { Euler, EventDispatcher, Vector3 } from 'three';
const _e = new Euler(0,0,0,'YXZ'), _v = new Vector3(), _cE = {type:'change'}, _lE = {type:'lock'}, _uE = {type:'unlock'}, _PI2 = Math.PI/2;
class PointerLockControls extends EventDispatcher {
	constructor(cam,dom){super();this.camera=cam;this.domElement=dom;this.isLocked=false;this.minPolarAngle=0;this.maxPolarAngle=Math.PI;this.pointerSpeed=1.0;this._onMM=onMM.bind(this);this._onPLC=onPLC.bind(this);this._onPLE=onPLE.bind(this);this.connect();}
	connect(){this.domElement.ownerDocument.addEventListener('mousemove',this._onMM);this.domElement.ownerDocument.addEventListener('pointerlockchange',this._onPLC);this.domElement.ownerDocument.addEventListener('pointerlockerror',this._onPLE);}
	disconnect(){this.domElement.ownerDocument.removeEventListener('mousemove',this._onMM);this.domElement.ownerDocument.removeEventListener('pointerlockchange',this._onPLC);this.domElement.ownerDocument.removeEventListener('pointerlockerror',this._onPLE);}
	dispose(){this.disconnect();}
	getObject(){return this.camera;}
	getDirection(v){return v.set(0,0,-1).applyQuaternion(this.camera.quaternion);}
	moveForward(dist){const cam=this.camera;_v.setFromMatrixColumn(cam.matrix,0);_v.crossVectors(cam.up,_v);cam.position.addScaledVector(_v,dist);}
	moveRight(dist){const cam=this.camera;_v.setFromMatrixColumn(cam.matrix,0);cam.position.addScaledVector(_v,dist);}
	lock(){this.domElement.requestPointerLock();}
	unlock(){this.domElement.ownerDocument.exitPointerLock();}
}
function onMM(e){if(this.isLocked===false)return;const mX=e.movementX||0,mY=e.movementY||0;const cam=this.camera;_e.setFromQuaternion(cam.quaternion);_e.y-=mX*0.002*this.pointerSpeed;_e.x-=mY*0.002*this.pointerSpeed;_e.x=Math.max(_PI2-this.maxPolarAngle,Math.min(_PI2-this.minPolarAngle,_e.x));cam.quaternion.setFromEuler(_e);this.dispatchEvent(_cE);}
function onPLC(){if(this.domElement.ownerDocument.pointerLockElement===this.domElement){this.dispatchEvent(_lE);this.isLocked=true;}else{this.dispatchEvent(_uE);this.isLocked=false;}}
function onPLE(){console.error('THREE.PointerLockControls: Unable to use Pointer Lock API');}
export { PointerLockControls };

create_file_with_block
js/main.js
import * as THREE from 'three';
import { PointerLockControls } from './vendor/three/examples/jsm/controls/PointerLockControls.js';

const { Labyrinth, Cell, GameConstants, LeonMath, Monster } = window; 
const PLAYER_RADIUS = 0.35; 
window.PLAYER_RADIUS = PLAYER_RADIUS; 

console.log("main.js loaded");

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x505060);
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
renderer.outputColorSpace = THREE.SRGBColorSpace; 

const ambientLight = new THREE.AmbientLight(0xffffff, 0.7); scene.add(ambientLight);
const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
directionalLight.position.set(20, 35, 18); 
directionalLight.castShadow = true;
directionalLight.shadow.mapSize.set(2048, 2048); 
directionalLight.shadow.camera.near = 0.5;    
directionalLight.shadow.camera.far = 80;   
directionalLight.shadow.camera.left = -30;
directionalLight.shadow.camera.right = 30;
directionalLight.shadow.camera.top = 30;
directionalLight.shadow.camera.bottom = -30;
scene.add(directionalLight);

const CELL_WIDTH = Labyrinth.CELLWIDTH, CELL_HEIGHT = Labyrinth.CELLHEIGHT;
const PLAYER_EYE_HEIGHT = CELL_HEIGHT * 0.75; 
const INTERACTION_DISTANCE = 3.0; // Increased slightly
const SHOOT_DISTANCE = 50; 

const labyrinth = new Labyrinth();
// Set anisotropy for all textures after they are loaded in Labyrinth constructor
const maxAnisotropy = renderer.capabilities.getMaxAnisotropy();
for (const key in labyrinth.textures) {
    if (labyrinth.textures[key] instanceof THREE.Texture) {
        labyrinth.textures[key].anisotropy = maxAnisotropy;
        labyrinth.textures[key].needsUpdate = true; 
    }
}
labyrinth.generateLabyrinth(); // Generates structure, places keys/gates/exit
labyrinth.create3DRepresentation(scene, CELL_WIDTH, CELL_HEIGHT, Labyrinth.WALLTHICKNESS); // Creates meshes

const player = {
    keys: {[GameConstants.KEY_RED]:false,[GameConstants.KEY_YELLOW]:false,[GameConstants.KEY_BLUE]:false},
    speed: 4.5, sprintMultiplier: 1.6, isGrounded: true, health: 100,
    currentFloor: 0, // 0 for ground, 1 for upper
    takeDamage: function(amount) {
        this.health -= amount;
        updateMessage(`OUCH! HP: ${this.health}`);
        if (this.health <= 0) {
            console.log("Player died!");
            controls.unlock(); 
            document.getElementById('instructions').innerHTML = '<p style="font-size:36px; color:red;">YOU DIED</p><p>Refresh to restart</p>';
            document.getElementById('blocker').style.backgroundColor = 'rgba(120,0,0,0.7)'; 
            document.getElementById('blocker').style.display = 'flex';
            document.getElementById('instructions').style.display = '';
        }
    }
};
window.playerHealthSystem = player; 

camera.position.set(Math.floor(Labyrinth.NUM_COLS/2)*CELL_WIDTH+CELL_WIDTH/2, PLAYER_EYE_HEIGHT, Math.floor(Labyrinth.NUM_ROWS/2)*CELL_WIDTH+CELL_WIDTH/2);
camera.userData.isPlayer = true; 

labyrinth.spawnMonsters(8, scene, {r: Math.floor(camera.position.z/CELL_WIDTH), c: Math.floor(camera.position.x/CELL_WIDTH)});


const blocker=document.getElementById('blocker'),instructions=document.getElementById('instructions'),messageArea=document.getElementById('message-area');
const controls = new PointerLockControls(camera, renderer.domElement);
instructions.addEventListener('click',()=>{controls.lock();});
controls.addEventListener('lock',()=>{instructions.style.display='none';blocker.style.display='none';messageArea.innerText='';});
controls.addEventListener('unlock',()=>{if(player.health > 0) {blocker.style.display='block';instructions.style.display='';}});
scene.add(controls.getObject()); 

const keyboardState = {};
document.addEventListener('keydown',(e)=>{keyboardState[e.code]=true;if(e.code==='KeyE'&&controls.isLocked)handleInteraction();});
document.addEventListener('keyup',(e)=>{keyboardState[e.code]=false;});
renderer.domElement.addEventListener('mousedown', (event) => { if(controls.isLocked && event.button === 0 && player.health > 0) handlePlayerShoot(); });


const clock = new THREE.Clock();
const interactionRaycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(), 0, INTERACTION_DISTANCE);
const shootRaycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(), 0, SHOOT_DISTANCE);

function updateMessage(msg, duration = 3000) {
    messageArea.innerText = msg;
    if(window.messageTimeout) clearTimeout(window.messageTimeout);
    if(duration > 0) window.messageTimeout = setTimeout(() => messageArea.innerText = '', duration);
}

function handleInteraction() {
    if(player.health <= 0) return;
    interactionRaycaster.setFromCamera({x:0,y:0}, camera); 

    // Key Pickup
    const keyIntersects = interactionRaycaster.intersectObjects(labyrinth.keyMeshes);
    if (keyIntersects.length > 0) {
        const keyM = keyIntersects[0].object; const {keyType,cellR,cellC}=keyM.userData;
        if (!player.keys[keyType]) {
            player.keys[keyType]=true; scene.remove(keyM); labyrinth.keyMeshes=labyrinth.keyMeshes.filter(k=>k!==keyM);
            const cell=labyrinth.getDownstairsCell(cellR,cellC); if(cell)cell.keyType=null; updateMessage(`Picked up ${keyType.replace('_',' ')}!`); return;
        }
    }
    // Gate Opening
    const gateIntersects = interactionRaycaster.intersectObjects(labyrinth.gateMeshes);
    if (gateIntersects.length > 0) {
        const gateM=gateIntersects[0].object; const {gateType,cellR,cellC}=gateM.userData;
        const cell=labyrinth.getDownstairsCell(cellR,cellC);
        if(cell&&cell.gateType===gateType&&!cell.isGateOpen){
            let reqKey=null; if(gateType===GameConstants.GATE_RED)reqKey=GameConstants.KEY_RED; else if(gateType===GameConstants.GATE_YELLOW)reqKey=GameConstants.KEY_YELLOW; else if(gateType===GameConstants.GATE_BLUE)reqKey=GameConstants.KEY_BLUE;
            if(reqKey&&player.keys[reqKey]){cell.isGateOpen=true;scene.remove(gateM);labyrinth.gateMeshes=labyrinth.gateMeshes.filter(g=>g!==gateM);updateMessage(`Opened ${gateType.replace('_',' ')}!`);}
            else updateMessage(`Need ${reqKey.replace('_',' ')} for ${gateType.replace('_',' ')}`); return;
        }
    }
    // Elevator Interaction
    const elevatorIntersects = interactionRaycaster.intersectObjects(labyrinth.elevatorPlatformMeshes);
    if (elevatorIntersects.length > 0) {
        const elevatorPlatformMesh = elevatorIntersects[0].object;
        const { cellR, cellC, currentFloor } = elevatorPlatformMesh.userData; // currentFloor is 0 or 1

        if (player.currentFloor === currentFloor) { // Ensure player is on the same floor as the platform they clicked
            if (player.currentFloor === 0) { // Go Up
                player.currentFloor = 1;
                camera.position.y = CELL_HEIGHT + PLAYER_EYE_HEIGHT;
                updateMessage("Elevator going UP!");
            } else { // Go Down
                player.currentFloor = 0;
                camera.position.y = PLAYER_EYE_HEIGHT;
                updateMessage("Elevator going DOWN!");
            }
            // Update player's conceptual position to match camera after teleport
            // This might be implicitly handled as camera.position IS player's position
            console.log(`Player used elevator. Now on floor: ${player.currentFloor}, Y: ${camera.position.y}`);
        } else {
            updateMessage("Elevator is on another floor.");
        }
        return;
    }

    // Exit Interaction
    if (labyrinth.exitMesh) {
        const exitIntersects = interactionRaycaster.intersectObjects([labyrinth.exitMesh]);
        if (exitIntersects.length > 0) {
            if (player.currentFloor === 1) { // Exit is on the upper floor
                if (player.keys[GameConstants.KEY_RED] && player.keys[GameConstants.KEY_YELLOW] && player.keys[GameConstants.KEY_BLUE]) {
                    updateMessage("Level Complete! Congratulations!", 0); 
                    controls.unlock();
                    document.getElementById('instructions').innerHTML = '<p style="font-size:36px; color:lime;">LEVEL COMPLETE!</p><p>You escaped the labyrinth!</p>';
                    document.getElementById('blocker').style.backgroundColor = 'rgba(0,50,0,0.7)';
                    document.getElementById('blocker').style.display = 'flex';
                    document.getElementById('instructions').style.display = '';
                    player.health = Infinity; 
                } else {
                    updateMessage("The exit hums... You need all three keys (Red, Yellow, Blue).");
                }
            } else {
                updateMessage("This exit portal feels distant... perhaps it's on another floor?");
            }
        }
    }
}

function handlePlayerShoot() {
    if(player.health <= 0) return;
    shootRaycaster.setFromCamera({x:0,y:0}, camera);
    const monsterMeshes = labyrinth.monsters.map(m => m.mesh).filter(m => m); 
    const intersects = shootRaycaster.intersectObjects(monsterMeshes);
    if (intersects.length > 0) {
        const firstHit = intersects[0].object;
        if (firstHit.userData && firstHit.userData.monster && typeof firstHit.userData.monster.takeDamage === 'function') {
            firstHit.userData.monster.takeDamage(25 + Math.floor(Math.random() * 10), scene); 
        }
    }
}

function handleMovement(dt) {
    if(!controls.isLocked || player.health <= 0) return;
    const speed=(keyboardState['ShiftLeft']||keyboardState['ShiftRight'])?player.speed*player.sprintMultiplier:player.speed;
    const moveDist=speed*dt; const p1=camera.position.clone(),p2t=p1.clone(),disp=new THREE.Vector3();
    const fwd=new THREE.Vector3(),rgt=new THREE.Vector3(); 
    camera.getWorldDirection(fwd); fwd.y=0; fwd.normalize(); 
    rgt.copy(fwd).applyAxisAngle(new THREE.Vector3(0,1,0), -Math.PI/2); 

    if(keyboardState['KeyW']||keyboardState['ArrowUp'])disp.addScaledVector(fwd,moveDist);
    if(keyboardState['KeyS']||keyboardState['ArrowDown'])disp.addScaledVector(fwd,-moveDist);
    if(keyboardState['KeyA']||keyboardState['ArrowLeft'])disp.addScaledVector(rgt,-moveDist);
    if(keyboardState['KeyD']||keyboardState['ArrowRight'])disp.addScaledVector(rgt,moveDist);
    
    p2t.add(disp); 
    
    // Set target Y based on player's current conceptual floor
    p2t.y = (player.currentFloor === 1) ? (CELL_HEIGHT + PLAYER_EYE_HEIGHT) : PLAYER_EYE_HEIGHT;

    const colN=new THREE.Vector3(); 
    labyrinth.crossLabyrinth(PLAYER_RADIUS,p1,p2t,colN,[]); 
    camera.position.copy(p2t);

    // Grounding check based on current floor
    const expectedY = (player.currentFloor === 1) ? (CELL_HEIGHT + PLAYER_EYE_HEIGHT) : PLAYER_EYE_HEIGHT;
    if(colN.y > 0.5 || Math.abs(camera.position.y - expectedY) < PLAYER_RADIUS + 0.1 ) {
        player.isGrounded = true;
        camera.position.y = expectedY; // Clamp to exact height if grounded
    } else {
        player.isGrounded = false;
    }
}

function animate() {
    requestAnimationFrame(animate);
    const dt=Math.min(0.05, clock.getDelta()); 
    if(controls.isLocked && player.health > 0) { 
        handleMovement(dt);
        labyrinth.monsters.forEach((m,idx)=>{if(m.isDead()){labyrinth.monsters.splice(idx,1);return;}m.update(dt,camera,labyrinth,scene);});
    }
    renderer.render(scene, camera);
}
window.addEventListener('resize',()=>{camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix();renderer.setSize(window.innerWidth,window.innerHeight);},false);
animate();
